"""
Automated tests for py2deb
==========================
"""

# Standard library modules.
import fnmatch
import functools
import glob
import logging
import os
import re
import shutil
import tempfile

# External dependencies.
import coloredlogs
from deb_pkg_tools.package import inspect_package
from executor import execute

# Initialize a logger.
logger = logging.getLogger(__name__)
execute = functools.partial(execute, logger=logger)

# Initialize (verbose) logging to the terminal.
coloredlogs.install()
coloredlogs.increase_verbosity()

# Find the sample packages that we're going to build during our tests.
TESTS_DIRECTORY = os.path.dirname(os.path.abspath(__file__))
TRIVIAL_PACKAGE_DIRECTORY = os.path.join(TESTS_DIRECTORY, 'samples', 'trivial-package')

def test_conversion_of_simple_package():

    """
    Convert a simple Python package (coloredlogs_) without any dependencies to
    a Debian package archive and sanity check the result. The conversion is
    done twice, once for each backend (stdeb vs pip-accel). Performs several
    static checks on the metadata and contents of the resulting package
    archive.

    .. _coloredlogs: https://pypi.python.org/pypi/coloredlogs
    """

    for py2deb_backend_option in ['--with-stdeb', '--with-pip-accel']:

        # Use a temporary directory as py2deb's repository directory so that we
        # can easily find the *.deb archive generated by py2deb.
        with TemporaryDirectory() as directory:

            # Run py2deb as a subprocess so that everything including py2deb.main() is run.
            execute('py2deb', '--repository=%s' % directory, py2deb_backend_option, 'coloredlogs==0.4.8')

            # Find the generated Debian package archive.
            archives = glob.glob('%s/*.deb' % directory)
            logger.debug("Found generated archive(s): %s", archives)
            assert len(archives) == 1

            # Use deb-pkg-tools to inspect the generated package.
            metadata, contents = inspect_package(archives[0])
            logger.debug("Metadata of generated package: %s", dict(metadata))
            logger.debug("Contents of generated package: %s", dict(contents))

            # Check the package metadata. It should look something like this:
            #
            # The package metadata produced by the stdeb backend:
            #
            #   {'Architecture': 'all',
            #    'Depends': 'python2.7, python (>= 2.7.1-0ubuntu2), python (<< 2.8)',
            #    'Description': 'Packaged by py2deb on May 7, 2014 at 00:58',
            #    'Installed-Size': '82',
            #    'Maintainer': 'Peter Odding <peter@peterodding.com>',
            #    'Package': 'python-coloredlogs',
            #    'Priority': 'optional',
            #    'Section': 'python',
            #    'Source': 'coloredlogs',
            #    'Version': '0.4.8-1'}
            #
            # The package metadata produced by the pip-accel backend:
            #
            #   ?
            #
            assert metadata['Package'] == 'python-coloredlogs'
            assert metadata['Version'].startswith('0.4.8')
            assert metadata['Architecture'] == 'all'

            # There should be exactly one dependency: some version of Python.
            assert has_dependency(metadata['Depends'], r'^python(\d+(\.\d+)*)?$')

            # Don't care about the format here as long as essential information is retained.
            assert 'Peter Odding' in metadata['Maintainer']
            assert 'peter@peterodding.com' in metadata['Maintainer']

            # Check the package contents. It should look something like this:
            #
            #  {'/': ArchiveEntry(permissions='drwxr-xr-x', owner='root', group='root', size=0, modified='2014-05-07 00:58', target=''),
            #   '/usr/bin/ansi2html': ArchiveEntry(permissions='-rwxr-xr-x', owner='root', group='root', size=317, modified='2014-05-07 00:58', target=''),
            #   '/usr/lib/python2.7/dist-packages/coloredlogs/__init__.py': ArchiveEntry(permissions='lrwxrwxrwx', owner='root', group='root', size=0, modified='2014-05-07 00:58', target='../../../../share/pyshared/coloredlogs/__init__.py'),
            #   '/usr/lib/python2.7/dist-packages/coloredlogs/converter.py': ArchiveEntry(permissions='lrwxrwxrwx', owner='root', group='root', size=0, modified='2014-05-07 00:58', target='../../../../share/pyshared/coloredlogs/converter.py'),
            #   '/usr/share/pyshared/coloredlogs/__init__.py': ArchiveEntry(permissions='-rw-r--r--', owner='root', group='root', size=9991, modified='2014-05-07 00:58', target=''),
            #   '/usr/share/pyshared/coloredlogs/converter.py': ArchiveEntry(permissions='-rw-r--r--', owner='root', group='root', size=3816, modified='2014-05-07 00:58', target=''),
            #   ...}

            # Check for the two *.py files that should be installed by the package.
            assert len(find_file(contents, '/usr/lib/python*/dist-packages/coloredlogs/__init__.py')) == 1
            assert len(find_file(contents, '/usr/lib/python*/dist-packages/coloredlogs/converter.py')) == 1

            # Make sure the file ownership and permissions are sane.
            entry = find_file(contents, '/usr/lib/python*/dist-packages/coloredlogs/__init__.py').values()[0]
            assert entry.owner == 'root'
            assert entry.group == 'root'
            assert entry.permissions in ('lrwxrwxrwx', # stdeb (the pyshared mechanism)
                                         '-rw-r--r--') # pip-accel (the dumb backend :-)

def test_conversion_of_package_with_dependencies():

    """
    Convert a Python package that has several dependencies (deb-pkg-tools_) to
    a Debian package archive and sanity check the result. The conversion is
    done twice, once for each backend (stdeb vs pip-accel). Performs static
    checks on the metadata (dependencies) of the resulting package archive.

    .. _deb-pkg-tools: https://pypi.python.org/pypi/deb-pkg-tools
    """

    for py2deb_backend_option in ['--with-stdeb', '--with-pip-accel']:

        # Use a temporary directory as py2deb's repository directory so that we
        # can easily find the *.deb archive generated by py2deb.
        with TemporaryDirectory() as directory:

            # Run py2deb as a subprocess so that everything including py2deb.main() is run.
            execute('py2deb', '--repository=%s' % directory, py2deb_backend_option, 'deb-pkg-tools==1.14.7')

            # Find the generated Debian package archives.
            archives = glob.glob('%s/*.deb' % directory)
            logger.debug("Found generated archive(s): %s", archives)

            # Make sure the expected dependencies have been converted.
            assert sorted(package_name_from_filename(a) for a in archives) == sorted([
                'python-chardet',
                'python-coloredlogs',
                'python-deb-pkg-tools',
                'python-debian',
                'python-executor',
                'python-humanfriendly',
            ])

            # Use deb-pkg-tools to inspect ... deb-pkg-tools :-)
            matches = [a for a in archives if 'deb-pkg-tools' in a]
            metadata, contents = inspect_package(matches[0])
            logger.debug("Metadata of generated package: %s", dict(metadata))
            logger.debug("Contents of generated package: %s", dict(contents))

            # Check the package metadata. It should look something like this:
            #
            # The package metadata produced by the stdeb backend:
            #
            #   {'Architecture': 'all',
            #    'Depends': 'apt, apt-utils, binutils, dpkg-dev, fakeroot, gnupg, lintian, python (<< 2.8), python (>= 2.7.1-0ubuntu2), python-chardet, python-coloredlogs (>= 0.4.6), python-debian (<< 0.1.22), python-debian (>= 0.1.21), python-executor (>= 1.1), python-humanfriendly (>= 1.7.1), python2.7',
            #    'Description': 'Packaged by py2deb on May 7, 2014 at 01:42',
            #    'Installed-Size': '140',
            #    'Maintainer': 'Peter Odding <peter@peterodding.com>',
            #    'Package': 'python-deb-pkg-tools',
            #    'Priority': 'optional',
            #    'Section': 'python',
            #    'Source': 'deb-pkg-tools',
            #    'Version': '1.14.7-1'}
            #
            # The package metadata produced by the pip-accel backend:
            #
            #   {'Architecture': 'all',
            #    'Depends': 'apt, apt-utils, binutils, dpkg-dev, fakeroot, gnupg, lintian, python-chardet, python-coloredlogs (>= 0.4.6), python-debian (<< 0.1.22), python-debian (>= 0.1.21), python-executor (>= 1.1), python-humanfriendly (>= 1.7.1), python2.7',
            #    'Description': 'Packaged by py2deb on May 7, 2014 at 01:42',
            #    'Installed-Size': '172',
            #    'Maintainer': 'Peter Odding <peter@peterodding.com>',
            #    'Package': 'python-deb-pkg-tools',
            #    'Priority': 'optional',
            #    'Section': 'python',
            #    'Version': '1.14.7-1',
            #    'Xs-Python-Version': '>= 2.6'}

            # Make sure the dependencies defined in `stdeb.cfg' have been preserved.
            for configured_dependency in ['apt', 'apt-utils', 'binutils', 'dpkg-dev', 'fakeroot', 'gnupg', 'lintian']:
                assert has_dependency(metadata['Depends'], '^%s$' % configured_dependency)

            # Make sure the dependencies defined in `setup.py' have been preserved.
            for python_dependency in ['python-chardet', 'python-coloredlogs', 'python-debian', 'python-executor', 'python-humanfriendly']:
                assert has_dependency(metadata['Depends'], '^%s' % python_dependency)

class TemporaryDirectory(object):

    """
    Easy temporary directory creation & cleanup using the :keyword:`with` statement:

    .. code-block:: python

       with TemporaryDirectory() as directory:
           # Do something useful here.
           assert os.path.isdir(directory)
    """

    def __enter__(self):
        self.temporary_directory = tempfile.mkdtemp()
        logger.debug("Created temporary directory: %s", self.temporary_directory)
        return self.temporary_directory

    def __exit__(self, exc_type, exc_value, traceback):
        logger.debug("Cleaning up temporary directory: %s", self.temporary_directory)
        shutil.rmtree(self.temporary_directory)
        del self.temporary_directory

def package_name_from_filename(pathname):
    filename = os.path.basename(pathname)
    components = filename.split('_')
    return components[0]

def has_dependency(depends_line, package_name):
    """
    Check if a package has a certain dependency.

    :param depends_line: The ``Depends:`` line of a binary package (a string).
    :param package_name: The name/version of the package (a string containing a
                         regular expression).
    :returns: ``True`` if the package has the dependency, ``False`` otherwise.
    """
    for dependency in depends_line.split(','):
        if re.match(package_name, dependency.strip()):
            return True

def find_file(contents, pattern):
    """
    Find the file(s) matching the given filename pattern in the dictionary of
    Debian package archive entries reported by
    :py:func:`deb_pkg_tools.package.inspect_package()`.

    :param contents: The dictionary of package archive entries.
    :param pattern: The filename pattern to match (:py:mod:`fnmatch` syntax).
    :returns: A subset of the original dictionary, containing only entries
              matching the pattern.
    """
    matches = {}
    for filename, metadata in contents.iteritems():
        if fnmatch.fnmatch(filename, pattern):
            matches[filename] = metadata
    return matches

# vim: ts=4 sw=4 et
